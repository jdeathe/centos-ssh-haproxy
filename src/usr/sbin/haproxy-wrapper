#!/usr/bin/env bash

readonly BIN="/usr/sbin/haproxy"
readonly BOOTSTRAP_LOCK_FILE="/var/lock/subsys/haproxy-bootstrap"
readonly CONFIG_PATH="/etc/haproxy/haproxy.cfg"
readonly LOCK_FILE="/var/lock/subsys/haproxy"
readonly PID_PATH="/var/run/haproxy.pid"

BLOCKER_PID=""
OPTIONS="
 -D
 -f ${CONFIG_PATH}
 -p ${PID_PATH}
"

function __is_valid_configuration ()
{
	${BIN} \
		-c \
		-q \
		-f ${CONFIG_PATH}

	if [[ ${?} -ne 0 ]]
	then
		printf -- \
			'Errors in configuration file.\n' \
			>&2
		return 1
	fi

	return 0
}

function reload ()
{
	local pids
	local return_value

	if ! __is_valid_configuration
	then
		return 1
	fi

	pids="$(
		cat "${PID_PATH}"
	)"

	if [[ -n ${pids} ]]
	then
		${BIN} \
			${OPTIONS} \
			-sf ${pids}
	else
		${BIN} \
			${OPTIONS}
	fi

	return_value=${?}

	if [[ -n ${BLOCKER_PID} ]]
	then
		kill ${BLOCKER_PID}
	fi

	# Create a lockfile on successful startup.
	if [[ ${return_value} -eq 0 ]]
	then
		touch \
			${LOCK_FILE}
	fi

	return ${return_value}
}

function start ()
{
	local return_value

	if ! __is_valid_configuration; then
		return 1
	fi

	${BIN} \
		${OPTIONS}

	return_value=${?}

	# Create a lockfile on successful startup.
	if [[ ${return_value} -eq 0 ]]
	then
		touch \
			${LOCK_FILE}
	fi

	return ${return_value}
}

function stop ()
{
	local return_value

	killall "$(
		basename \
		${BIN}
	)"

	return_value=${?}

	if [[ -n ${BLOCKER_PID} ]]
	then
		kill ${BLOCKER_PID}
	fi

	# Remove the lockfile on successful stop.
	if [[ ${return_value} -eq 0 ]]
	then
		rm -f \
			${LOCK_FILE}
	fi

	return ${return_value}
}

# Use SIGHUP, (kill -1 <pid>), signal to reload instead of stop.
trap reload \
	HUP
trap stop \
	INT TERM EXIT

while true
do
	sleep 0.1
	[[ -e ${BOOTSTRAP_LOCK_FILE} ]] || break
done

start

# Keep script in the foreground and allow reload/stop traps to function.
while [[ -e ${LOCK_FILE} ]]
do
	sleep \
		infinity &
	BLOCKER_PID=${!}
	wait ${BLOCKER_PID}
done
