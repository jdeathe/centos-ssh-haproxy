#!/usr/bin/env bash

set -e

function __cleanup ()
{
	__delete_lock
}

function __create_lock ()
{
	if [[ -n ${lock_file} ]]
	then
		touch "${lock_file}"
	fi
}

function __delete_lock ()
{
	if [[ -f ${lock_file} ]]
	then
		rm -f "${lock_file}"
	fi
}

function __get_options ()
{
	local -r options="${1}"

	local pids

	if [[ -s ${pid_path} ]] \
		&& ps axo command \
			| grep -qE "^${bin} "
	then
		# reload
		pids="$(< "${pid_path}")"

		printf -- \
			'-D -f %s -p %s -sf %s%s%s' \
			"${config_path}" \
			"${pid_path}" \
			"${pids}" \
			"${options:+" "}" \
			"${options}"
	else
		# start
		printf -- \
			'-D -f %s -p %s%s%s' \
			"${config_path}" \
			"${pid_path}" \
			"${options:+" "}" \
			"${options}"
	fi
}

function __get_proxy ()
{
	printf -- \
		'%s -n %s' \
		"${nice}" \
		"${niceness}"
}

function __is_valid_configuration ()
{
	${bin} \
		-c \
		-q \
		-f ${config_path}

	if [[ ${?} -ne 0 ]]
	then
		return 1
	fi

	return 0
}

function __reload ()
{
	local options
	local proxy
	local return_value

	if ! __is_valid_configuration
	then
		>&2 printf -- \
			'ERROR: %s configuration error\n' \
			"${0##*/}"
		return 1
	fi

	options="$(
		__get_options
	)"
	proxy="$(
		__get_proxy
	)"

	if [[ ${verbose} == true ]]
	then
		printf -- \
			'INFO: %s reloading %s\n' \
			"${0##*/}" \
			"${bin##*/}"
	fi

	${proxy} \
		${bin} \
		${options}

	return_value="${?}"

	if [[ -n ${blocker_pid} ]]
	then
		kill ${blocker_pid}
	fi

	# Create a lockfile on successful startup.
	if [[ ${return_value} -eq 0 ]]
	then
		__create_lock
	fi

	return "${return_value}"
}

function __start ()
{
	local options
	local proxy
	local return_value

	if ! __is_valid_configuration
	then
		>&2 printf -- \
			'ERROR: %s configuration error\n' \
			"${0##*/}"
		return 1
	fi

	options="$(
		__get_options
	)"
	proxy="$(
		__get_proxy
	)"

	if [[ ${verbose} == true ]]
	then
		printf -- \
			'INFO: %s starting %s\n' \
			"${0##*/}" \
			"${bin##*/}"
	fi

	${proxy} \
		${bin} \
		${options}

	return_value="${?}"

	# Create a lockfile on successful startup.
	if [[ ${return_value} -eq 0 ]]
	then
		__create_lock
	fi

	return "${return_value}"
}

function __soft_stop ()
{
	local return_value

	if [[ ${verbose} == true ]]
	then
		printf -- \
			'INFO: %s soft-stopping %s\n' \
			"${0##*/}" \
			"${bin##*/}"
	fi

	killall \
		-w \
		-s USR1 \
		"$(
			basename \
				"${bin}"
		)"

	return_value="${?}"

	if [[ -n ${blocker_pid} ]]
	then
		kill ${blocker_pid}
	fi

	# Remove the lockfile on successful stop.
	if [[ ${return_value} -eq 0 ]]
	then
		__delete_lock
	fi

	return "${return_value}"
}

function __stop ()
{
	local return_value

	if [[ ${verbose} == true ]]
	then
		printf -- \
			'INFO: %s stopping %s\n' \
			"${0##*/}" \
			"${bin##*/}"
	fi

	killall "$(
		basename \
			"${bin}"
	)"

	return_value="${?}"

	if [[ -n ${blocker_pid} ]]
	then
		kill ${blocker_pid}
	fi

	# Remove the lockfile on successful stop.
	if [[ ${return_value} -eq 0 ]]
	then
		__delete_lock
	fi

	return "${return_value}"
}

function main ()
{
	local -r bin="/usr/sbin/haproxy"
	local -r bootstrap_state_file="/var/lib/misc/haproxy-bootstrap"
	local -r bootstrap_timeout="4"
	local -r config_path="/etc/haproxy/haproxy.cfg"
	local -r lock_file="/var/lock/subsys/haproxy-wrapper"
	local -r nice="/bin/nice"
	local -r niceness="10"
	local -r pid_path="/var/run/haproxy.pid"
	local -r stats_socket="/var/lib/haproxy/stats-1"

	local blocker_pid
	local verbose="false"

	while [[ "${#}" -gt 0 ]]
	do
		case "${1}" in
			-v|--verbose)
				verbose="true"
				shift 1
				;;
		esac
	done

	if [[ -f ${lock_file} ]]
	then
		>&2 printf -- \
			'ERROR: %s lock detected - aborting\n' \
			"${0##*/}"
		exit 1
	fi

	trap "__reload" \
		HUP
	trap "__soft_stop" \
		USR1
	trap "__stop" \
		EXIT INT TERM

	if [[ ${verbose} == true ]] \
		&& [[ ! -f ${bootstrap_state_file} ]]
	then
		printf -- \
			'INFO: %s waiting on %s\n' \
			"${0##*/}" \
			"${bootstrap_state_file##*/}"
	fi

	set +e
	until [[ -f ${bootstrap_state_file} ]]
	do
		if ! inotifywait -qq \
			-e "create" \
			-t "${bootstrap_timeout}" \
			"${bootstrap_state_file%/*}"
		then
			break
		fi
	done
	set -e

	if [[ ! -f ${bootstrap_state_file} ]]
	then
		>&2 printf -- \
			'ERROR: %s timed out waiting on %s\n' \
			"${0##*/}" \
			"${bootstrap_state_file##*/}"
		exit 1
	fi

	__start

	# Keep script in the foreground and allow traps to function.
	while [[ -f ${lock_file} ]]
	do
		set +e
		sleep \
			infinity &
		blocker_pid="${!}"
		wait ${blocker_pid}
		set -e
	done

	trap - \
		EXIT HUP INT TERM USR1
}

main "${@}"
